<!DOCTYPE html> 
<head>
    <title>Доп. задание #3</title>
	<meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="stylet.css">
<body>
<p><b>Дополнительное задание #2. Последовательный интерфейс доски Боггл</b></p>
<p>На этой неделе вы начнете разработку пользовательского интерфейса игры Боггл. Сосредоточимся на двух классах; один это "кнопка Боггл" которая отображает одну букву на доске Боггл, и другой класс "доска Боггл" который управляет отображением всей доски.</p>
<p>Чтобы облегчить себе жизнь, создайте свои классы пользовательского интерфейса на основе имеющихся классов Swing, просто расширьте их возможности там где это необходимо. Ваш класс Боггл-копка должен наследоваться от <tt>javax.swing.JButton</tt>, а класс Боггл-доска, содержащий коллекцию кнопок Боггл, должен наследоваться от <tt>javax.swing.JPanel</tt>.</p>
<p>И не забудьте как обычно добавить комментарии Javadoc к всему коду который вы напишите,</p>
<p><b>Вспоминаем пользовательский интерфейс Swing</b></p>
<p>Если вы забыли как добавляются обработчики событий для компонентов пользовательского интерфейсаSwing, то вот некоторые детали:</p>
<ul>
<li>Обрабатывайте события <tt>ActionEvent</tt> от кнопок <tt>JButton</tt>, а не сообщения от мыши. Кнопки Swing также обрабатывают сами события от клавиатуры. Для обработки событий от кнопок надо зарегистрировать обработчики сообщений от самих кнопок.</li>
<li>Обычно лучше всего обрабатывать события во вложенном классе, так чтобы публичный интерфейс основного класса не содержал ничего связанного с обработкой событий. В слайдах этот вопрос рассматривается более подробно.</li>
<li>Помните, что все компоненты Swing не доступны из фоновых потоков! Вы должны обращаться к ним только из потока диспетчера Swing. Поэтому в первой части курса Java мы обсуждали класс <tt>javax.swing.SwingUtilities</tt>. Перечитайте этот материал. Мы также рассмотрим пример кода, который использует <tt>SwingUtilities</tt>, но вам скоро придется писать свой собсвтенный код.</li>
</ul>
<p><b>Боггл-кнопки</b></p>
<p>Ваш класс отображения Боггл-копки должен прорисовывать одну клетку на доске Боггл. В этом нет ничего концептуально сложного. Но мы хотим сделать для пользователя красивые подсказки, которые облегчают чтение игрового поля и отображают список слов из которых можно делать выбор. Но об этом после.</p>
<p>Назовите свой класс "кнопки Боггл" использую те же соглашения имен, которые приняты для именования компонентов Swing. Имена этих компонентов начинаются с буквы "J". Например, этот класс можно назвать "JBoggleButton."</p>
<p>Состояние кнопки Боггл должно хранить три вещи:</p>
<ol>
<li>
<p>Позиция кнопки на игровом поле Боггл. С этим можно поспорить, но некоторые свойства поля Боггл описанные ниже, гораздо легче реализовать, если кнопки знают свое место на доске.</p>
<p>Позицию можно указать парой значений (x, y), конечно считая от нуля. Пусть позиция кнопки указывается в конструкторе, и кроме этого добавьте аксессоры.</p>
<p>Не называйте аксессоры <tt>getX()</tt> и <tt>getY()</tt>!!! У компонентов Swing уже есть аксессоры с этими именами. Они используются для позиционирования компонентов пользовательского интерфейса в контейнере Swing. Совпадающие имена перепутают расположение компонентов вашего пользовательского интерфейса. (Я потратил несколько часов в поисках этого бага, не повторяйте той же ошибки!) Назовите аксессоры как нибудь иначе, например <tt>getBoardX()</tt> и <tt>getBoardY()</tt>.</p>
</li>
<li>Значение кнопки Боггл типа <tt>String</tt>. Можете воспользоваться готовыми методами <tt>getText()</tt> и <tt>setText(String)</tt> класса <tt>JButton</tt>, или сделать собственное <tt>поле</tt> и пару аксессор/мутатор. Опишите ваше решение в комментариях Javadoc вашего класса.</li>
<li>
<p>Текущее состояние кнопки Боггл. Это состояние должно принимать одно из следующих значений:</p>
<ul>
<li>"Недоступна," означает, что пользователь не может выбрать эту кнопку.</li>
<li>"Доступна," означает, что кнопка не выбрана, но пользователь может ее выбрать.</li>
<li>"Выбрана," означает, что кнопка выбрана и является частью составляемого слова.</li>
</ul>
<p>Для определения этих состояний воспользуйтесь перечисляемым типом (<tt>enum</tt>) Java (назовите его, например, "State"). Добавьте к вашему классу кнопки переменную этого типа с модификатором public. Теперь код внутри класса может использовать эти состояния, и код использующий этот ваш класс тоже имеет доступ к информации о состоянии кнопки.</p>
<p>Сделайте аксессор и мутатор для состояния кнопки. Мутатор дополнительно должен прорисовывать внешний вид кнопки, в соответствии с ее текущим состоянием. (Детали приведены ниже.)</p>
</li>
</ol>
<p>Мы хотим, чтобы пользовательский интерфейс был хорошо читаемым, и мы не хотим использовать для надписей шрифт "по умолчанию". Поэтому в конструкторе вашего класса, установите для кнопки большой легко читаемый шрифт. (Например шрифт sans-serif размером в 40-пунктов, ну или может быть вам больше нравятся шрифты serif.)</p>
<p><b>Рамки кнопки Боггл</b></p>
<p>Кнопки Боггл должны отображать свое текущее состояние (недоступна, доступна или выбрана) с помощью двух визуальных эффектов: "активного" состояния, и цвета рамки. Изменить "активное" состояние компонента Swing легко, но <tt>JButton</tt> по умолчанию не имеет рамки, поэтому ее нужно добавить с помощью метода <tt>setBorder(Border)</tt>.</p>
<p>Добавьте к своему классу кнопки три константы: UNAVAILABLE_BORDER, AVAILABLE_BORDER, и SELECTED_BORDER. (Эти константы должны иметь модификатор доступа private, потому, что они нужны только внутри класса. Объявите их как <tt>private static final</tt>.) Проинициализируйте каждую константу вызовом подходящего метода <tt>javax.swing.BorderFactory</tt>, чтобы создать сплошную рамку шириной три пикселя.</p>
<ul>
<li>Рамка "недоступна" должна быть серой.</li>
<li>Рамка "доступна" должна быть зеленой.</li>
<li>Рамка "выбрана" должна быть красной.</li>
</ul>
<p>После того как вы сделаете таким образом все три рамки, можно дописать ваш "изменяющий состояние" мутатор так, чтобы он менял внешний вид кнопки, следующим образом:</p>
<ul>
<li>Если состояние кнопки "недоступна," кнопка должна стать неактивной (disabled) и получить серую рамку.</li>
<li>Если состояние кнопки "доступна," она должна быть активна (enabled) и иметь зеленую рамку.</li>
<li>Если состояние кнопки "выбрана," она должна быть активна (enabled) и иметь красную рамку.</li>
</ul>
<p>Как было указано выше, внешний вид кнопки надо менять в "изменяющем состояние" мутаторе. Дополнительно вызовите этот мутатор из конструктора; Не меняйте эти значения нигде кроме как внутри мутатора.</p>
<p><b>Отображение досок Боггл</b></p>
<p>Когда ваш класс кнопки Боггл будет готов , можно перейти к классу "Доска Боггл". Этот класс должен прорисовывать доску размером N×N составленную из кнопок Boggle, позволять пользователям создавать слова из букв на игровом поле Боггл. Следуя правилам именования компонентов пользовательского интерфейса Swing, вам следует назвать этот класс "JBoggleBoard". Конструктор класса имеет единственный аргумент N, задающий размерность отображаемой доски.</p>
<p>Класс JBoggleBoard конечно должен иметь ссылку на экземпляр класса <tt>BoggleBoard</tt>, и кнопки которые отображают содержимое объекта <tt>BoggleBoard</tt>.</p>
<p>Отображение доски это не столь сложная задача, так как у вас уже есть класс кнопки Боггл. Можно сделать такой метод:</p>
<pre>    public void setBoard(BoggleBoard b)</pre>
<p>Метод просто в цикле перебирает все кнопки, устанавливая состояние каждой, так чтобы оно соответствовало значению клетки взятому из <tt>BoggleBoard</tt>. (Можно вызывать исключение <tt>IllegalArgumentException</tt> если размер <tt>BoggleBoard</tt> не совпадает с размером <tt>JBoggleBoard</tt>.)</p>
<p><b>Построение слов</b></p>
<p>Хотя этот класс может просто давать игроку возможность нажать любую уже использованную кнопку, нам хочется добавить к этому классу больше функций. По мере того как игрок формирует слово, мы хотим показывать игроку какие буквы уже являются частью этого слова (потому что каждая клетка доски может использоваться в слове только один раз), а также какие буквы еще доступны для выбора. Итак будем контролировать выбор следующим образом:</p>
<p>Заведем список (т.е. <tt>ArrayList</tt>) "выбранных кнопок". Первоначально список пуст, и кнопки добавляются к нему по мере того как игрок составляет свое слово.</p>
<ul>
<li>
<p>Сначала, когда еще нет выбранных букв, все кнопки должны быть в состоянии "доступны", потому, что игрок может выбрать любую букву. Вот картинка на которой показано это состояние:</p>
<img src="https://moodle.iu3.bmstu.ru/pluginfile.php/2098/mod_page/content/3/board1.png" width="290" height="300" /></li>
<li>
<p>Когда кнопка выбрана, она добавляется в список выбранных кнопок. Каждая кнопка которая попадает в список "выбранных" кнопок должна находится в состоянии "выбрана", и следовательно иметь красную рамку.</p>
<p><em>Последняя</em> кнопка в списке "выбранных" особенная: все кнопки в одном шаге от последней выбранной кнопки должны быть установлены в состояние "доступны," кроме тех которые уже выбраны.</p>
<p>Все другие кнопки должны иметь состояние "недоступны." И тогда, игрок может делать только правильные ходы, т.е. ходы соответствующие правилам игры Боггл.</p>
<p>Вот пример той же доски после того как выбрана первая клетка:</p>
<img src="https://moodle.iu3.bmstu.ru/pluginfile.php/2098/mod_page/content/3/board2.png" width="290" height="300" />
<p>И той же доски, после того как выбраны три клетки:</p>
<img src="https://moodle.iu3.bmstu.ru/pluginfile.php/2098/mod_page/content/3/board4.png" width="290" height="300" />
<p>Видно, что выбранные буквы всегда обозначаются красной рамкой, а "доступные" буквы которые можно выбрать на следующем ходе, обозначаются зеленой рамкой. Все другие кнопки неактивны, поэтому игрок не может их выбрать.</p>
</li>
</ul>
<p>Есть несколько способов обновлять изображение доски, но легче всего создать отдельный private метод который выполняет задачу обновления состояний кнопок. Он должен обрабатывать два случая:</p>
<ol>
<li>Если выбранные кнопки отсутствуют, перебрать все кнопки и изменить их состояние на "доступны."</li>
<li>Иначе выполнить эти шаги:<ol style="list-style-type: lower-alpha;">
<li>Перебрать все кнопки и установить их в состояние "недоступны."</li>
<li>Перебрать все элементы списка выбранных кнопок, и установить каждую кнопку из списка в состояние "выбрана."</li>
<li>Извлечь <em>последнюю</em> кнопку из списка выбранных, и установить всех ее соседей в состояние "доступны," если их нет в списке "выбранных кнопок". <em>(Подсказка: Возможность получения позиции кнопки на доске может быть очень полезна на этом шаге ...)</em></li>
</ol></li>
</ol>
<p>Есть еще одна ситуация которую должен обрабатывать класс отображающий доску. Если пользователь нажимает на кнопку, которая уже выбрана. В этом случае, нужно сократить список выбранных кнопок до этой кнопки, и затем соответственно обновить состояния кнопок. Это свойство программы позволит игроку отменять свои ходы и продолжать игру с позиции до которой сделана отмена.</p>
<p><b>Методы</b></p>
<p>Вот список методов которые должны быть реализованы в вашем классе JBoggleButton:</p>
<ul>
<li>Метод для "сброса состояний" который очищает список выбранных кнопок и затем перерисовывает изображение доски.</li>
<li>Метод для "извлечения слова", который перебирает список выбранных кнопок и возвращает строку составленную из букв этих кнопок. Преобразуйте строку в нижний регистр прежде чем возвращать ее. Если выбранных кнопок нет, верните пустую строку "", а не <tt>null</tt>.</li>
</ul>
<p><b>Тестирование кода</b></p>
<p>Так как тестировать классы пользовательского интерфейса как правило очень сложно, вам нужно всего лишь добавить простой метод <tt>main()</tt> к классу <tt>JBoggleBoard</tt>. Он должен вывести доску на экран, для того чтобы убедиться, что она работает. Он должен выглядеть примерно так:</p>
<pre>    public static void main(String[] args) {
        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
              JFrame f = new JFrame("BoggleTest");
              f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

              JBoggleBoard boardGUI = new JBoggleBoard(BoggleBoard.DEFAULT_SIZE);
              f.add(boardGUI);

              f.pack();
              f.setVisible(true);
              f.setSize(300, 300);

              boardGUI.setBoard(new BoggleBoard());
            }
        });
    }</pre>
<p>После того как вы добавили подобный код к классу <tt>JBoggleBoard</tt>, его можно запустить в командной строке, вот так:</p>
<pre>    java JBoggleBoard</pre>
<p>Если все сделано правильно, вы увидите свой пользовательский интерфейс, и сможете составлять слова на доске Боггл.</p>
<p>Если вы желаете улучшить свою программу, вот некоторые идеи:</p>
<ul>
<li>Измените ваш перечисляемый класс <tt>JBoggleButton.State</tt> так, чтобы он включал поля хранящие рамку и настройку активен/неактивен для каждого состояния. Тогда ваш мутатор меняющий состояние сможет сам использовать объект <tt>State</tt> для обновления конфигурации кнопки.</li>
<li>Класс кнопки Боггл может обрабатывать событие "изменение размера компонента", для того, чтобы масштабировать шрифт относительно размера кнопки.</li>
<li>В нашем проекте пользовательского интерфейса легко запутаться в отображаемых словах; например, можно выбрать последовательность букв, которая пересекает сама себя на экране. Нужно создать набор иконок со стрелками, и затем прорисовывать их на панели(возможно с помощью собственного кода который дополняет "стандартную" процедуру прорисовки панели). Это нужно для того, чтобы показать порядок в котором были выбраны буквы. Когда несколько букв для каждой пары соседних выбранных букв нужно прорисовывать стрелку показывающую от буквы выбранной раньше на букву выбранную позже.</li>
<li>Найдите способ, сделать кнопку похожей на настоящую фишку Боггл а не просто на кнопку Swing. Попробуйте вставить изображение в фон изображения кнопки. Вы даже можете повернуть буквы на 90°, 180°, или 270° случайным образом, для имитации настоящей игры Боггл.</li>
</ul>
<div align="center"><hr size="2" width="100%" noshade="noshade" align="center" /></div>
<p>Copyright (C) 2015, California Institute of Technology. All rights reserved.</p>
</body>
</html>