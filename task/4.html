<!DOCTYPE html> 
<head>
    <title>Задание #4</title>
	<meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="stylet.css">
<body>
<p><b>Задание #4. Программа для изучения фракталов</b></p>
<p>В нескольких следующих лабораторных работах вы соберете любопытное небольшое Java приложение, которое сможет рисовать удивительные изображения фракталов. Если вы до сих пор не занимались фракталами, вы будете поражены тем, как просто можно создавать потрясающе красивые изображения. Мы сделаем это все с помощью Swing Framework, функций Java API которые позволяют создавать графический пользовательский интерфейс.</p>
<p>Мы будем создавать это приложение на нескольких лабораторных работах, и наша первая версия будет очень проста, но в следующих лабораторных работах мы добавим  к нему разные полезные функции, такие например как способность сохранять созданные изображения, и переключаться между различными видами фракталов. Графический пользовательский интерфейс сам по себе и механизм для реализации различных фракталов зависит от иерархии классов.</p>
<p>Вот простой пример пользовательского интерфейса в начальном состоянии:</p>
<p><img src="explorer.png" width="480" height="531" style="display: block; margin-left: auto; margin-right: auto;" /></p>
<p>А вот некоторые интересные области фрактала: морские берега и слоны!</p>
<p style="text-align: center;"><span style="line-height: 1.4;"><img src="seahorses.png" width="480" height="531" /><img src="elephants.png" width="480" height="531" /> </span></p>
<p><b>Создание пользовательского интерфейса</b></p>
<p>Перед тем, как начать рисование фракталов нужно создать графический виджет, который позволит это сделать. Swing не имеет такого компонента, но можно легко сделать его самим. Заметим, что мы будем использовать в этой работе большое количество классов Java AWT и Swing, и просто невозможно в деталях описать каждый из них. Одако, в этом нет необходимости, так как доступная онлайн <a href="http://docs.oracle.com/javase/6/docs/api/">Документация Java API </a>очень содержательна и проста в использовании. Перейдите к описанию пакета, в котором расположен нужный вам Java класс, выберете этот класс из списка, и прочтите подробную информацию о том как им пользоваться.</p>
<ul>
<li>Создайте класс <code>JImageDisplay</code> наследованный от <code>javax.swing.JComponent</code>. Класс должен иметь одно private поле, экземпляр класса <code>java.awt.image.BufferedImage</code>. Класс <code>BufferedImage</code> будет управлять изображением с которым мы будем работать.</li>
<li>Конструктор <code>JImageDisplay</code> должен получать целые ширину и высоту и инициализировать поле <code>BufferedImage</code> ссылкой на новое изображение заданной ширины и высоты. Тип изображения должен быть равен <code>TYPE_INT_RGB</code>. Тип просто указывает формат представления цветов пикселов изображения; указанный тип означает что красный, зеленый и синий компоненты цвета каждая занимает 8 бит, и располагаются в перечисленном порядке в переменной целого типа.</li>
</ul>
<p>Ваш конструктор должен делать еще кое что: он должен вызывать метод родительского класса setPreferredSize() передавая ему заданные ширину и высоту. (Эти значения следует передать в объекте типа <code>java.awt.Dimension</code>, который специально создается для этого вызова.) Тогда компонент, который вы создаете, начнет прорисовывать изображение после того как будет добавлен к пользовательскому интерфейсу.</p>
<ul>
<li>Пользовательский компонент Swing должен сам прорисовывать себя переопределив метод <code>protected paintComponent(Graphics g)</code> класса <code>JComponent</code>. Так как наш компонент просто сам выводит изображение, наша реализация будет очень проста! Во первых, реализация <code>paintComponent(g)</code> суперкласса <span style="text-decoration: underline;">должна вызываться</span> в любом случае, для того чтобы все рамки и другие элементы правильно прорисовывались. После вызова метода суперкласса, вы можете нарисовать изображение в области компонента, используя подобные операции:</li>
</ul>
<p><code>g.drawImage(image, 0, 0, image.getWidth(), image.getHeight(), null);</code></p>
<p>(Мы указываем <code>null</code> в аргументе <code>ImageObserver</code>, потому что не нуждаемся в этом функционале)</p>
<ul>
<li>Вам также потребуется создать два public метода для записи данных в изображение: <code>clearImage()</code> который устанавливает черный цвет для всех пикселов изображения (значение RGB 0) и drawPixel(int x, int y, int rgbColor) которых задает указанный цвет пиксела. Оба эти метода должны использовать один из методов <code>setRGB()</code> класса <code>BufferedImage</code>.</li>
<li>Конечно, не забудьте написать понятные, полные и  немногословные комментарии для класса и методов, объясняющие, что они делают.</li>
</ul>
<p><b>Вычисление</b><b> </b><b>фрактала</b><b> </b><b>Мандельброта</b><b> </b></p>
<p>Затем вы напишите код для вычисления очень хорошо известного фрактала Мандельброта. Для того чтобы в будущем поддержать отображение нескольких фракталов,  вы начнете с файла <a href="https://dl.dropbox.com/u/57328246/java/lab4/FractalGenerator.java">FractalGenerator.java</a> , от которого будут наследованы все другие генераторы фракталов. Обратите внимание на имеющиеся там очень полезные операции, транслирующие координаты экрана в систему координат вычисляемого фрактала.</p>
<p>Виды фракталов, с которыми нам предстоит иметь дело, вычисляются в комплексной области, и состоят из очень простых математических функций, которые периодически повторяются до тех пор, пока не выполнятся некоторые условия. Функция фрактала Мандельброта <i>z<sub>n</sub></i>= <i>z<sub>n</sub></i><sub>-1</sub><sup>2</sup> + <i>c</i>, где все значения комплексные числа, <i>z</i><sub>0</sub> = 0, и <i>c</i> особая отображаемая точка фрактала. Эти вычисления повторяются до тех пор, пока или |<i>z</i>| &gt; 2 (в таком случае точка не принадлежит множеству Мандельброта), или пока количество итераций не достигнет максимального, например 2000 (в этом случае мы предполагаем, что точка принадлежит множеству).</p>
<p>Процесс прорисовки множества Мандельбота очень простой: перебираем все точки изображения, вычисляем количество итераций для  каждой координаты изображения и закрашиваем точку цветом, зависящим от этого числа итераций. Но это уже следующая задача, сейчас надо просто реализовать описанные выше вычисления.</p>
<ul>
<li>Создайте дочерний класс <code>FractalGenerator</code> с именем <code>Mandelbrot</code>. Вы должны в дочернем классе реализовать только два метода, <code>getInitialRange()</code> и <code>numIterations()</code>.</li>
<li>Метод <code>getInitialRange(Rectangle2D.Double)</code> позволяет указать генератору фрактала, какая часть комплектной области "интересна" для вычисления фрактала. Обратите внимание на то, что объект прямоугольник передается как аргумент метода, и метод должен изменить поля прямоугольника так чтобы он содержал правильный начальный диапазон вычислений фрактала . (Посмотрите пример в методе <code>FractalGenerator.recenterAndZoomRange()</code>.) Реализация этого метода в классе Mandelbrot  должна устанавливать начальный диапазон (-2 - 1.5<i>i</i>) - (1 + 1.5<i>i</i>). То есть, значения <i>x</i> и <i>y</i> должны быть -2 и -1.5 соответственно, а ширина и высота должны быть одинаковы и равны 3.</li>
<li>Метод <code>numIterations(double, double)</code> должен содержать реализацию итеративной функции фрактала Мандельброта. Можете определить константу для указания "максимального числа итераций " как эта:</li>
</ul>
<pre>  public static final int MAX_ITERATIONS = 2000;</pre>
<p>Затем вы можете использовать ее в своих вычислениях.</p>
<p>Учтите, что в Java отсутствует тип данных для комплексных чисел, так что вам понадобится реализовать итеративную функцию, используя отдельные double компоненты для хранения действительной  и мнимой частей числа. (Вероятно вы способны сделать свой собственный класс для работы с комплексными числами, однако скорее всего дело того не стоит.) Можете попытаться увеличить скорость вычислений; например, не сравнивайте |<i>z</i>| с 2; сравнивайте |<i>z</i>|<sup>2</sup> с 2<sup>2</sup> (с 4 J) чтобы избежать вычисления медленной функции квадратного корня. Не используйте для вычисления целых степеней метод Math.pow(); умножайте значения, иначе ваш код будет очень медленным.</p>
<p>Когда вы сделали <code>MAX_ITERATIONS</code> итераций просто верните -1 для того чтобы указать на то что точка не вышла за пределы множества.</p>
<p><b>Собираем</b><b> </b><b>все</b><b> </b><b>вместе</b><b></b></p>
<p>Наконец все готово для того чтобы рисовать фракталы! Теперь надо создать класс <code>FractalExplorer</code> который позволит вам изучить различные фрагменты фрактала, вычисляя их и отображая на экране с помощью графического интерфейса Swing, а также обработать различные сообщения от пользователя.</p>
<p>Как вы могли видеть на примерах представленных ранее изображений пользовательского интерфейса, Fractal Explorer очень простая программа, состоящая из JFrame с объектом JImageDisplay который отображает фрактал, и одной кнопкой <code>JButton</code> для сброса экрана в начальное состояние, так чтобы он показывал фрактал целиком. Для того чтобы сделать такую простую структуру приложения, поместите панель <code>BorderLayout</code>, в <code>JFrame</code> затем расположите <code>JImageDisplay</code> в центре панели и оставшуюся кнопку в "южной (south)"  части панели.</p>
<ul>
<li>В классе <code>FractalExplorer</code> нужно будет хранить некоторую важную информацию о состоянии программы:</li>
<ul>
<li>Целое значение "размера экрана", число, задающее одновременно высоту и ширину области отображения. (Мы рисуем фрактал в квадрате.)</li>
<li>Ссылка на объект <code>JImageDisplay</code>, для того чтобы мы имели возможность изменять изображение из различных методов класса по мере вычисления фрактала.</li>
<li>Объект <code>FractalGenerator</code>. Здесь следует использовать ссылку на базовый класс, для того чтобы в будущих версиях можно было показывать на экране различные типы фракталов.</li>
<li>Объект <code>Rectangle2D.Double</code>, который задает отображаемый диапазон в комплексной области.</li>
</ul>
</ul>
<p>Конечно, все эти поля должны иметь модификатор доступа private...</p>
<ul>
<li>Класс должен иметь конструктор, который получает через аргумент размер экрана, затем сохраняет это значение в предназначенном для этого поле, и инициализирует диапазон объекта генератора фрактала. Заметьте, что конструктор не должен настраивать никакие компоненты Swing; это будет сделано в следующем методе.</li>
<li>Создайте метод <code>createAndShowGUI()</code> который инициализирует графический пользовательский интерфейс Swing: объект <code>JFrame</code> содержащий объект <code>JImageDisplay</code> и кнопку для сброса экрана в начальное состояние. JFame должен использовать объект java.awt.BorderLayout для расположения своих дочерних элементов; добавьте объект картинки <code>JImageDisplay</code>  в позицию <code>BorderLayout.CENTER</code>, а кнопку в позицию <code>BorderLayout.SOUTH</code>.</li>
</ul>
<p>Задайте подходящий для приложения заголовок в <code>JFrame</code> и укажите операцию "exit" по умолчанию при закрытии окна (см документацию на метод <code>JFrame.setDefaultCloseOperation()</code>).</p>
<p>В конце, после того как компоненты пользовательcкого интерфейса проинициализированы и размещены в окне, добавьте эту последовательность вызовов:</p>
<pre>  frame.pack();
  frame.setVisible(true);
  frame.setResizable(false);</pre>
<ul>
<li>Они правильно расположат содержимое окна, сделают окно видимым ( после создания окна оно невидимо; это сделано для того чтобы сначала можно было расставить все элементы интерфейса а затем их прорисовать на экране) и наконец запретят изменение размеров окна.</li>
<li>Для прорисовки фрактала надо сделать вспомогательный метод, например drawFractal(). Это метод должен перебирать точки изображения (то есть по координате <i>x</i> от 0 до размера экрана, и также по <i>y</i>), и делать следующее:</li>
<ul>
<li>Вычислить количество итераций для соответствующей координаты в области отображения фрактала . Значение координат с плавающей точкой для указанной точки изображения можно получить с помощью вспомогательной функции <code>FractalGenerator.getCoord();</code> например, для того, чтобы получить координату x соответствующую точке изображения с координатой X надо сделать так:</li>
</ul>
</ul>
<pre x="" xcoord="" li="">  double xCoord = FractalGenerator.getCoord(range.x, range.x + range.width, displaySize, x);</pre>
<ul>
<ul>
<li>Если количество итераций равно -1 (то есть точка не вышла из множества), цвет точки будет черным (rgb 0). Иначе, следует выбрать значение цвета в зависимости от количества итераций. Мы можем воспользоваться цветовой моделью   <a href="http://en.wikipedia.org/wiki/HSV_color_space">цветовой моделью HSV</a>:  изменяя тон в пределах от 0 до 1, мы получим плавную последовательность цветов от красного через желтый, зеленый, синий, фиолетовый обратно к красному! Цвет можно вычислять так:</li>
</ul>
</ul>
<pre>  float hue = 0.7f + (float) numIters / 200f;
  int rgbColor = Color.HSBtoRGB(hue, 1f, 1f);</pre>
<p>Конечно, если у вас появится другая интересная идея вычисления цвета по количеству итераций, можете ее реализовать.</p>
<ul>
<li>Вы должны перерисовать каждую точку изображения с помощью метода <code>drawPixel()</code>.</li>
<li>Наконец, завершив прорисовку всех точек изображения, следует обновить на экране изображение JImageDisplay . Для этого вызовите для этого компонента метод repaint(). Если вы забудете это сделать, ваш экран никогда не обновится!</li>
</ul>
<ul>
<li>Создайте внутренний класс для обработки событий <code>java.awt.event.ActionListener</code> от кнопки сброса. Обработчик просто должен сбрасывать диапазон отображения в начальное значение, указанное при инициализации генератора, и затем перерисовывать фрактал.</li>
</ul>
<p>Закончив с этим классом, добавьте в метод <code>createAndShowGUI()</code> регистрацию обработчика кнопки сброса.</p>
<ul>
<li>Создайте другой внутренний класс для обработки событий <code>java.awt.event.MouseListener</code> от <code>JImageDisplay</code>. Нам нужна лишь обработка событий щелчка мышью, поэтому внутренний класс надо сделать наследником AWT класса <code>MouseAdapter</code> о котором говорилось в третьей лекции. Получив сообщение о щелчке мышью, обработчик должен преобразовать координаты точки изображения в отображаемую область фрактала и вызвать метод генератора <code>srecenterAndZoomRange()</code> с новыми координатами и масштабом 0.5. Так щелчком мыши по изображению фрактала можно будет увеличить изображение в этом месте!</li>
</ul>
<p>Конечно, не забудьте перерисовать фрактал после изменения области отображения.</p>
<p>После того как класс будет готов добавьте к методу <code>createAndShowGUI()</code> регистрацию обработчика события от <code>JImageDisplay</code>.</p>
<ul>
<li>Наконец, вам надо создать статический метод main() программы изучения фракталов, чтобы можно было ее запустить. В этой версии метод main очень простой:</li>
<ul>
<li>Создайте экземпляр класса <code>FractalExplorer</code> с размером экрана 800 точек (или сколько желаете, но не слишком большой).</li>
<li>Вызовите метод <code>createAndShowGUI()</code> этого объекта.</li>
<li>Вызовите метод <code>drawFractal()</code> этого объекта для того чтобы вычислить и вывести на экран изображение фрактала!</li>
</ul>
</ul>
<p>Теперь вы можете изучать фрактал Мандельброта, рассматривая его удивительные детали. Если вы сильно увеличите изображение, то столкнетесь с некоторыми интересными проблемами:</p>
<ul>
<li>Во первых, вы обнаружите что уровень детализации в какой то момент перестает увеличиваться; это происходит потому что нам требуется более 2000 итераций для того чтобы определить принадлежит точка множеству Мандельброта или нет! Конечно, мы можем увеличить максимальное число итераций, но тогда черные области фрактала уменьшат скорость работы нашей программы!</li>
<li>Во вторых, если вы сделаете увеличение очень большим, вы, в конце концов, увидите увеличенные пикселы!  Это происходит потому, что достигнут предел точности представления чисел с плавающей точкой  в формате double.</li>
</ul>
<p>Возможно, вы обратите внимание на то, что изображение “ подвисает ” во время перерисовки фрактала. Этот эффект мы изучим в следующих лабораторных работах, и вместе с этим рассмотрим как увеличить скорость прорисовки фрактала используя несколько процессоров.</p>
<div align="center"><hr size="2" width="100%" noshade="noshade" align="center" /></div>
<p>Copyright (C) 2015, California Institute of Technology. All rights reserved.</p>
</body>
</html>